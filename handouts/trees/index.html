<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=windows-1252"
      http-equiv="Content-Type">
    <title>Trees</title>
  </head>
  <body>
    <span style="font-weight: bold;">Objectives</span><br>
    <br>
    - Provide an overview of trees and their terminology<br>
    <br> 
    <br>
    - Examine applications that use trees.<br>
    <br>

    <span style="font-weight: bold;" id="introduction">Introduction</span><br>
    <p>
    A <b>tree</b> is a fundamental data structure in computer science that
    illustrates a hierarchical relationship between data. A very basic tree
    looks like this:
    <br>
    <img src="basicTree.svg"></img> 
    <br>

    We say that P is the <b>parent</b> of LC and RC. LC is the <b>child</b> of
    P. (I named it LC because it is the left child of P; what does RC
    stand for?) All three &#8212 P, LC, and RC &#8212 are <b>nodes</b> of the
    tree.</p>

    <p>
    Even though LC is the child of P, it can have children of its own. In the
    following graph, LC is both a parent and a child. It is the child of P and
    the parent of LC.LC.  <br>
    <img src="lcParent.svg"></img> 
    <br>
    </p> 

    <p>A node that has no parent is special, it is the <b>root</b> of
    the tree:
    <br>
    <img src="rootDemo.svg"></img> 
    <br>
    A node that has no children is also special. It is a <b>leaf</b>.
    <br>
    <img src="rootLeaf.svg"></img>
    <br>
    </p>

    <br>
    <span style="font-weight: bold;">Vocabulary</span><br>
    <br>
    Below is a graph with common terms for relationships in trees.<br>
    <br>
    <div style="margin-left: 80px;"><a href="./trees.png"><img
          target="_blank" alt="" src="./trees.png"
          style="border-top-width: 0px; border-right-width: 0px;
          border-bottom-width: 0px; border-left-width: 0px;
          border-top-style: solid; border-right-style: solid;
          border-bottom-style: solid; border-left-style: solid;
          border-top-color: -moz-use-text-color; border-right-color:
          -moz-use-text-color; border-bottom-color: -moz-use-text-color;
          border-left-color: -moz-use-text-color;
          -moz-border-top-colors: none; -moz-border-right-colors: none;
          -moz-border-bottom-colors: none; -moz-border-left-colors:
          none; border-image-source: none; border-image-slice: 100% 100%
          100% 100%; border-image-width: 1 1 1 1; border-image-outset: 0
          0 0 0; border-image-repeat: stretch stretch; width: 400px;
          height: 299px;" border="0" height="1530" width="2014"></a><br>
    </div>
    <br>
    * Notice how counting begins at level zero!<br>
    <br>
    <span style="font-weight: bold;">Binary Tree </span><br>
    <br>
    The tree shown above is a special type of tree known as a <span
      style="font-weight: bold;">binary tree</span> which means that a
    node can have 0, 1, or<span style="font-weight: bold;"></span> 2
    children. <br>
    <br>
    When a tree
    <ul>
    <li>has height h, and</li> 
    <li>all of its leaves are at level h, and</li>
    <li>all nodes that have children have exactly two children, then</li>
    </ul> 
    it is a special kind of tree known as a <b>full</b> binary tree.
    <br>
    <div style="margin-left: 80px;"><img style="width: 350px; height:
        201px;" alt="" src="./full-binary-tree.png"><br>
    </div>
    <br>
    In a <b>complete binary tree</b>, all nodes that have children must have two
    children. Also, the tree is filled from left to right, as shown below. If,
    however, node R had two children, the below tree woud not be complete.<br>
    <br>
    <div style="margin-left: 80px;"><img style="width: 350px; height:
        270px;" alt="" src="./complete.png"><br>
    </div>
    <br>
    <span style="font-weight: bold;">General Trees</span><br>
    <br>
    A <span style="font-weight: bold;">general tree</span> has no
    restriction on the number of children a node may have.<br>
    <br>
    <div style="margin-left: 80px;"><img style="width: 450px; height:
        262px;" alt="" src="./general-tree.png"><br>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;" id="traversals">Traversals of a Binary Tree</span><br>
    <br>
    Consider the following tree<br>
    <br>
    <div style="margin-left: 80px;"><img style="width: 500px; height:
        366px;" alt="" src="./traversals.png"><br>
    </div>
    <br>
    <br>
    A <span style="font-weight: bold;">traversal</span> involves <span
      style="font-weight: bold;">visiting</span> a node exactly once. For
      example, we may traverse the tree above by visiting J, F, T, C, H, W, A,
      D, V, and Z in that order. There are many different possible traversals.
      Can you think of another one?

	<p>Although we may define a traversal by listing the nodes in order, as
	we did above, we may also define traversals algorithmically. To
	do this, we must first define a tree in a recursive way. A recursive
	definition defines an object in terms of itself. We will define big
	trees in terms of smaller trees.</p>

	<p> A <b>binary tree</b> is either
	<ul>
		<li>a root that has two <b>binary trees</b>  as children, or</li> 
		<li>empty</li> 
	</ul> 
	All binary trees can be defined this way.
	For example, the following tree: 
	<br>
	<img src="nonRecursive.svg"></img> 
	<br>
	can be defined as a collection of seven little recursive trees, as
	shown below:
	<br>
	<img src="recursiveTree.svg"></img> 
	<br>
	Can we define the following tree recursively?
	<br>
	<img src="nonRecursive1.svg"></img> 
	<br>
	Yes. It can be broken down into five little recursive trees.
	<br>
	<img src="rec2.svg"></img> 
	<br>
	</p>

   	<p>
<iframe width="560px" height="320px" allowfullscreen="true" src="https://westminster.instructuremedia.com/embed/18c12b92-61dd-4158-b027-6a2524a20eab" frameborder="0"></iframe>
	</p> 
	
    <br>
    <span style="font-weight: bold;">Pre-Order Traversal</span><br>
    Instead of providing the order of the nodes,  we will traverse the
    following tree by providing an algorithm :
    <br>
    <div style="margin-left: 40px;">1. Visit the root<br>
      <br>
      2. Traverse left subtree<br>
      <br>
      3. Traverse right subtree<br>
    </div>
    <br>
    Note that this is a recursive algorithm. The pre-order traversal
    visits the nodes in the following order:<br>
    <br>
    <div style="margin-left: 40px;"><big><big><span style="font-weight:
            bold;">J, F, C, A, D, H, T, W, V, Z</span></big></big><br>
    </div>
    <div style="margin-left: 80px;"><img style="width: 500px; height:
        366px;" alt="" src="./traversals.png"><br></div>
    <br>
   	<p>
<iframe width="560px" height="320px" allowfullscreen="true" src="https://westminster.instructuremedia.com/embed/18c12b92-61dd-4158-b027-6a2524a20eab" frameborder="0"></iframe>
	</p> 
 

<p>
<iframe width="560px" height="320px" allowfullscreen="true" src="https://westminster.instructuremedia.com/embed/a218369b-f23c-407a-9d89-73c5f76f614a" frameborder="0"></iframe>
</p> 

    <br>
    <span style="font-weight: bold;">In-Order Traversal</span><br>
    <br>
    <div style="margin-left: 40px;">1. Traverse left subtree<br>
      <br>
      2. Visit the root<br>
      <br>
      3. Traverse right subtree<br>
    </div>
    <br>
    The output<br>
    <br>
    <div style="margin-left: 40px;"><big><big><span style="font-weight:
            bold;">A, C, D F, H, J, T, V, W, Z</span></big></big><br>
    </div>
    <br>
    <span style="font-weight: bold;">Post-Order Traversal</span><br>
    <br>
    1. Traverse left subtree<br>
    <br>
    2. Traverse right subtree<br>
    <br>
    3. Visit the root<br>
    <br>
    The output<br>
    <br>
    <div style="margin-left: 40px;"><big><big><span style="font-weight:
            bold;">A, D, C, H, F, V, Z, W, T, J</span></big></big><br>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;">Binary Search Trees</span><br>
    &nbsp;<br>
    A binary search tree (BST) is a special type of tree with the
    following requirement<br>
    <br>
    <div style="margin-left: 40px;"><img style="width: 450px; height:
        182px;" alt="" src="./bst.png"><br>
    </div>
    <br>
    <span style="font-weight: bold;">Constructing Binary Search Trees</span><br>
    <br>
    Inserting the following elements into a binary search tree<br>
    <br>
    <div style="margin-left: 40px;"><big><big><span style="font-weight:
            bold;">16, 19, 2, 4, 3, 1, 9, 12, 18, 27</span></big></big><br>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;">Deleting from a Binary Search Tree</span><br>
    <br>
    Three Cases:<br>
    <br>
    <span style="font-weight: bold;">#1 - Removing a Leaf Node</span><br>
    <br>
    <div style="margin-left: 40px;">This is trivial.<br>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;">#2 - Removing a Node with One Child</span><br>
    <br>
    <div style="margin-left: 40px;"><img style="width: 771px; height:
        550px;" alt="" src="./BST-Delete-P1.jpg"><br>
    </div>
    <br>
    <span style="font-weight: bold;">#3 - Removing a Node with Two
      Children</span><br>
    <br>
    <div style="margin-left: 40px;"><img style="width: 649px; height:
        273px;" alt="" src="./BST-Delete-P2.jpg"><br>
    </div>
    <p>To delete the value, we will actually swap it out for a value that will
    not distrupt the BST's structure. Then we will delete the extra copy of the
    value that was swapped in. The illustrated algorithm is below:
    <ol>

	<li>Pick a <b>successor</b> to the node that will be deleted. The
	successor is a node that contains the value that is closest to the
	value of the node to be deleted. This is either then next largest
	number or the next smallest number. Therefore, the successor is either
	the right-most node in the left subtree (next smallest) or the leftmost
	node in the right subtree (next largest). In the figure below, the next
	smallest is 30 and the next largest is 55. Either one could be the
	successor.
	<br>
	<img src="delete0.svg"></img> 
 	</li> 

	<li>Copy the value of the successor into the node whose value will be
	deleted. This remnoves the desired value from the tree, but leaves an
	extra copy of the successor. In the following figure, we chose 30 as
	the successor. We could have chosen 55 as well.

    <br>
    <img src="delete1.svg"></img> 
    <br>
	</li>

	<li>Delete the successor node since it contains the extra copy.
	<br>
	<img src="delete2.svg"></img> 
	</li> 
    </ol>
    </p> 
    </p> 

  </body>
</html>
